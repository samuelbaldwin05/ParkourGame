<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Industrial Minecraft Parkour Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            font-family: 'Consolas', 'Monaco', monospace;
            overflow: hidden;
            cursor: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: linear-gradient(to bottom, #34495e 0%, #2c3e50 100%);
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #00ff41;
            box-shadow: 0 0 4px #00ff41;
        }

        .crosshair::before {
            width: 1px;
            height: 8px;
            top: 4px;
            left: 7px;
        }

        .crosshair::after {
            width: 8px;
            height: 1px;
            top: 7px;
            left: 4px;
        }

        .hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff41;
            font-weight: bold;
            font-family: 'Consolas', monospace;
            text-shadow: 0 0 8px #00ff41;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #00ff41;
            border-radius: 3px;
            pointer-events: none;
        }

        .controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #7f8c8d;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 1px solid #7f8c8d;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
            line-height: 1.4;
            pointer-events: none;
        }

        .completion-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #00ff41;
            padding: 30px;
            border: 2px solid #00ff41;
            border-radius: 3px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            font-family: 'Consolas', monospace;
            display: none;
            pointer-events: all;
            z-index: 2000;
            box-shadow: 0 0 20px #00ff41;
        }

        .reset-btn {
            margin-top: 20px;
            padding: 10px 20px;
            background: transparent;
            color: #00ff41;
            border: 1px solid #00ff41;
            border-radius: 3px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Consolas', monospace;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: #00ff41;
            color: #000;
            box-shadow: 0 0 10px #00ff41;
        }

        .stats-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: #7f8c8d;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border: 1px solid #7f8c8d;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            font-size: 12px;
        }

        .game-message {
            position: fixed;
            bottom: 150px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: #00ff41;
            padding: 10px 20px;
            border: 1px solid #00ff41;
            border-radius: 3px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'Consolas', monospace;
            z-index: 1500;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            text-align: center;
        }

        .game-message.show {
            opacity: 1;
        }

        .game-message.checkpoint {
            color: #00ff41;
            border-color: #00ff41;
            box-shadow: 0 0 10px #00ff41;
        }

        .game-message.fall {
            color: #e74c3c;
            border-color: #e74c3c;
            box-shadow: 0 0 10px #e74c3c;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-overlay">
            <div class="crosshair"></div>
            
            <div class="hud">
                <div>CHECKPOINT: <span id="checkpointCount">0</span>/6</div>
                <div>TIME: <span id="timer">0:00</span></div>
                <div>FALLS: <span id="fallCount">0</span></div>
            </div>

            <div class="stats-panel">
                <div>SPEED: <span id="speedDisplay">0.0</span> BPS</div>
                <div>STATUS: <span id="jumpStatus">GROUND</span></div>
                <div>HEIGHT: <span id="heightDisplay">1.0</span>m</div>
            </div>

            <div class="controls-help">
                <strong>CONTROLS:</strong><br>
                WASD - MOVE<br>
                SPACE - JUMP<br>
                SHIFT - SPRINT<br>
                MOUSE - LOOK<br>
                CLICK TO START
            </div>

            <div class="completion-message" id="completionMessage">
                <div>COURSE COMPLETED</div>
                <div id="finalStats" style="margin-top: 10px; font-size: 16px;"></div>
                <button class="reset-btn" onclick="resetGame()">RESTART</button>
            </div>

            <div class="game-message" id="gameMessage"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game variables
        let scene, camera, renderer, player;
        let keys = {};
        let mouseX = 0, mouseY = 0;
        let velocity = new THREE.Vector3();
        let canJump = false;
        let isOnGround = false;
        let isSprinting = false;
        let blocks = [];
        let checkpoints = [];
        let currentCheckpoint = 0;
        let startTime = Date.now();
        let fallCount = 0;
        let gameCompleted = false;

        // Block materials - industrial theme
        const materials = {
            normal: new THREE.MeshLambertMaterial({ color: 0x7f8c8d }),
            start: new THREE.MeshLambertMaterial({ color: 0x2ecc71 }),
            checkpoint: new THREE.MeshLambertMaterial({ color: 0x3498db }),
            end: new THREE.MeshLambertMaterial({ color: 0xf1c40f }),
            slime: new THREE.MeshLambertMaterial({ 
                color: 0x2ecc71, 
                transparent: true, 
                opacity: 0.8,
                emissive: 0x002200
            })
        };

        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x2c3e50, 20, 100);

            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2.8, 0);

            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x2c3e50);

            // Add lighting - softer industrial style
            const ambientLight = new THREE.AmbientLight(0x404040, 0.7);
            scene.add(ambientLight);

            // Main directional light - reduced intensity
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(30, 40, 30);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 200;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Create player collision cylinder
            const playerGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.8, 8);
            const playerMaterial = new THREE.MeshBasicMaterial({ visible: false });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 1.9, 0);
            scene.add(player);

            createCourse();
            setupEventListeners();
            animate();
        }

        function createBlock(x, y, z, type) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const mesh = new THREE.Mesh(geometry, materials[type]);
            
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            // Add special properties
            mesh.userData = {
                type: type,
                isSlime: type === 'slime',
                isCheckpoint: type === 'checkpoint' || type === 'start' || type === 'end'
            };
            
            scene.add(mesh);
            blocks.push(mesh);
            
            return mesh;
        }

        function createPlatform(x, y, z, width, depth, type) {
            for (let i = 0; i < width; i++) {
                for (let j = 0; j < depth; j++) {
                    createBlock(x + i, y, z + j, type);
                }
            }
        }

        function createCourse() {
            // Starting platform (3x3)
            createPlatform(0, 0, 0, 3, 3, 'start');
            checkpoints.push(new THREE.Vector3(1, 1, 1));

            // Basic jumps
            createPlatform(5, 0, 0, 2, 2, 'normal');
            createPlatform(8, 0, 0, 2, 2, 'normal');
            createPlatform(12, 1, 0, 2, 2, 'normal');

            // Checkpoint 1 (3x3)
            createPlatform(16, 1, 0, 3, 3, 'checkpoint');
            checkpoints.push(new THREE.Vector3(17, 2, 1));

            // Side path with height changes
            createBlock(19, 2, 2, 'normal');
            createBlock(21, 3, 4, 'normal');
            createBlock(23, 4, 6, 'normal');

            // Slime bounce section - adjusted for better jump
            createPlatform(25, 2, 8, 2, 2, 'slime');
            createPlatform(28, 5, 10, 2, 2, 'normal'); // Lowered from 6 to 5

            // Checkpoint 2 (2x2) - adjusted height
            createPlatform(31, 5, 12, 2, 2, 'checkpoint'); // Lowered from 6 to 5
            checkpoints.push(new THREE.Vector3(32, 6, 13));

            // Precision jumps (single blocks) - adjusted heights
            createBlock(34, 5, 15, 'normal'); // Lowered from 6 to 5
            createBlock(36, 6, 18, 'normal'); // Lowered from 7 to 6
            createBlock(38, 7, 21, 'normal'); // Lowered from 8 to 7

            // Long jump challenge - adjusted
            createPlatform(40, 7, 24, 2, 2, 'normal'); // Lowered from 8 to 7
            createPlatform(45, 8, 24, 2, 2, 'normal'); // Lowered from 9 to 8

            // Checkpoint 3 (3x2) - adjusted
            createPlatform(49, 8, 24, 3, 2, 'checkpoint'); // Lowered from 9 to 8
            checkpoints.push(new THREE.Vector3(50, 9, 25));

            // Descending spiral
            createBlock(52, 8, 27, 'normal');
            createBlock(54, 7, 29, 'normal');
            createBlock(56, 6, 31, 'normal');
            createBlock(58, 5, 33, 'normal');

            // Final slime boost
            createPlatform(60, 3, 35, 2, 2, 'slime');
            createPlatform(63, 5, 38, 2, 2, 'normal');

            // Victory platform (4x4)
            createPlatform(66, 6, 40, 4, 4, 'end');
            checkpoints.push(new THREE.Vector3(68, 9, 42));
        }

        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                if (event.code === 'Space') {
                    event.preventDefault();
                }
            });

            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });

            // Mouse events
            document.addEventListener('click', () => {
                if (document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('mousemove', (event) => {
                if (document.pointerLockElement === document.body) {
                    mouseX -= event.movementX * 0.002;
                    mouseY -= event.movementY * 0.002;
                    mouseY = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouseY));
                }
            });

            // Window resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function updatePlayer() {
            if (gameCompleted) return;

            // Handle sprinting
            isSprinting = keys['ShiftLeft'] || keys['ShiftRight'];
            
            // Movement input
            let moveVector = new THREE.Vector3();
            if (keys['KeyW']) moveVector.z -= 1;
            if (keys['KeyS']) moveVector.z += 1;
            if (keys['KeyA']) moveVector.x -= 1;
            if (keys['KeyD']) moveVector.x += 1;

            // Normalize movement vector
            if (moveVector.length() > 0) {
                moveVector.normalize();
                
                // Apply camera rotation to movement
                moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouseX);
                
                // Determine movement speed based on ground/air state
                const baseSpeed = isSprinting ? 0.009 : 0.006;
                const movementSpeed = isOnGround ? baseSpeed : baseSpeed * 0.08;
                
                // Apply movement force
                velocity.x += moveVector.x * movementSpeed;
                velocity.z += moveVector.z * movementSpeed;
            }

            // Jumping
            if (keys['Space'] && canJump) {
                velocity.y = 0.055;
                canJump = false;
                isOnGround = false;
            }

            // Apply gravity
            velocity.y += -0.0012;

            // Apply friction and air resistance
            if (isOnGround) {
                velocity.x *= 0.82;
                velocity.z *= 0.82;
            } else {
                velocity.x *= 0.99;
                velocity.z *= 0.99;
            }

            checkCollisions();

            // Update camera rotation
            camera.rotation.order = 'YXZ';
            camera.rotation.y = mouseX;
            camera.rotation.x = mouseY;

            updateUI();
        }

        function checkCollisions() {
            const futurePosition = player.position.clone().add(velocity);
            let onGround = false;
            let onSlime = false;

            // Check collision with each block
            blocks.forEach(block => {
                const blockBox = new THREE.Box3().setFromObject(block);
                const playerBox = new THREE.Box3().setFromCenterAndSize(
                    futurePosition,
                    new THREE.Vector3(0.6, 1.8, 0.6)
                );

                if (blockBox.intersectsBox(playerBox)) {
                    const blockCenter = new THREE.Vector3();
                    blockBox.getCenter(blockCenter);
                    
                    const dx = futurePosition.x - blockCenter.x;
                    const dy = futurePosition.y - blockCenter.y;
                    const dz = futurePosition.z - blockCenter.z;
                    
                    // Vertical collision
                    if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > Math.abs(dz)) {
                        if (dy > 0) { // Player above block
                            futurePosition.y = blockBox.max.y + 0.9;
                            velocity.y = 0;
                            onGround = true;
                            canJump = true;
                            
                            if (block.userData.isSlime) onSlime = true;
                            
                            // Check checkpoint
                            if (block.userData.isCheckpoint && 
                                checkpoints[currentCheckpoint] && 
                                futurePosition.distanceTo(checkpoints[currentCheckpoint]) < 2) {
                                if (currentCheckpoint < checkpoints.length - 1) {
                                    currentCheckpoint++;
                                    showMessage(`CHECKPOINT ${currentCheckpoint}/6 REACHED`, 'checkpoint');
                                } else if (!gameCompleted) {
                                    completeGame();
                                }
                            }
                        } else { // Player below block
                            futurePosition.y = blockBox.min.y - 0.9;
                            velocity.y = 0;
                        }
                    }
                    // Horizontal collision
                    else {
                        if (Math.abs(dx) > Math.abs(dz)) {
                            futurePosition.x = dx > 0 ? blockBox.max.x + 0.3 : blockBox.min.x - 0.3;
                            velocity.x = 0;
                        } else {
                            futurePosition.z = dz > 0 ? blockBox.max.z + 0.3 : blockBox.min.z - 0.3;
                            velocity.z = 0;
                        }
                    }
                }
            });

            // Apply slime bounce
            if (onSlime && velocity.y <= 0) {
                velocity.y = 0.08;
                onGround = false;
                canJump = false;
            }

            isOnGround = onGround;

            // Check for falling off the course
            if (futurePosition.y < -10) {
                if (checkpoints[Math.max(0, currentCheckpoint - 1)]) {
                    const checkpoint = checkpoints[Math.max(0, currentCheckpoint - 1)];
                    player.position.copy(checkpoint);
                    player.position.y += 1;
                    velocity.set(0, 0, 0);
                    fallCount++;
                    showMessage('RESPAWNED AT CHECKPOINT', 'fall');
                } else {
                    player.position.set(1, 1.9, 1);
                    velocity.set(0, 0, 0);
                    fallCount++;
                    showMessage('RETURNED TO START', 'fall');
                }
                return;
            }

            // Apply final position
            player.position.copy(futurePosition);
            camera.position.copy(player.position);
            camera.position.y += 0.7;
        }

        function updateUI() {
            const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsedTime / 60);
            const seconds = elapsedTime % 60;
            document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            document.getElementById('checkpointCount').textContent = currentCheckpoint;
            document.getElementById('fallCount').textContent = fallCount;

            const horizontalVelocity = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
            document.getElementById('speedDisplay').textContent = (horizontalVelocity * 100).toFixed(1);
            
            document.getElementById('jumpStatus').textContent = isOnGround ? 'GROUND' : 'AIRBORNE';
            document.getElementById('heightDisplay').textContent = player.position.y.toFixed(1);
        }

        function showMessage(text, type) {
            const messageElement = document.getElementById('gameMessage');
            messageElement.textContent = text;
            messageElement.className = `game-message ${type} show`;
            
            setTimeout(() => {
                messageElement.classList.remove('show');
            }, 2500);
        }

        function completeGame() {
            if (gameCompleted) return;
            
            gameCompleted = true;
            const totalTime = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(totalTime / 60);
            const seconds = totalTime % 60;
            
            document.getElementById('finalStats').innerHTML = `
                TIME: ${minutes}:${seconds.toString().padStart(2, '0')}<br>
                FALLS: ${fallCount}<br>
                ${fallCount === 0 ? 'PERFECT RUN' : 'GOOD JOB'}
            `;
            
            document.getElementById('completionMessage').style.display = 'block';
        }

        function resetGame() {
            gameCompleted = false;
            currentCheckpoint = 0;
            fallCount = 0;
            startTime = Date.now();
            
            player.position.set(1, 1.9, 1);
            camera.position.copy(player.position);
            camera.position.y += 0.7;
            velocity.set(0, 0, 0);
            
            mouseX = 0;
            mouseY = 0;
            
            document.getElementById('completionMessage').style.display = 'none';
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePlayer();
            renderer.render(scene, camera);
        }

        // Start the game
        init();
    </script>
</body>
</html>